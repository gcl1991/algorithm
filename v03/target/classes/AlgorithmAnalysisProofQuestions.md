## 3.1 打印指定位置的值

见代码（没想出只使用Collections的public方法，在打印时使用了List的get方法）

时间复杂度$N*O(max(Collections.min(),Collections.replaceAll())$

## 3.3~3.5已经在程序中实现

## 3.6 josephus问题

a 使用双链表迭代器，在迭代器上进行remove较为高效

b 时间复杂度$(m+1)*(n-1)$

假设外层循环需要x次

有 $x*n/(m+1)=n-1$,每隔m删除1个，所以是m+1,同时需要保留最后一个所以共删除n-1个元素。

则时间复杂度$n*x=(m+1)*(n-1)$

## 3.7 时间复杂度

循环N次，表中数量增长1，2，...，N，每次均进行表元素复制

即(1+N)*N/2=O(N2)



## 3.8 删除表前半部分问题

a 因为在删除过程中，表的尺寸会发生改变

b N,N-1,...,N/2=(N+N/2)*(N/2)/2=O(N2)

c  因为是表首移除，时间为O(N)

d  不会变快

## 3.9 addAll问题

已实现，运行时间O(N)，在尾节点之前插入。

## 3.10  removeAll问题

对items进行排序NlogN，然后使用迭代器循环MyArrayList，利用二分法查询每个元素是否在items中，如果存在则删除。

时间复杂度O(NlogN)

## 3.11 只具有头节点的单链表

在代码中实现

主要考察链的移动，注意空指针

## 3.12 单链表排序

这个没有实现，比较简单，可以使用简单排序：冒泡，插入，选择

## 3.13 ArrayList增加ListIterator接口

已在代码中实现，主要注意索引的移动和非法性检测