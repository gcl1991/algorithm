## 3.1 打印指定位置的值

见代码（没想出只使用Collections的public方法，在打印时使用了List的get方法）

时间复杂度$N*O(max(Collections.min(),Collections.replaceAll())$

## 3.3~3.5已经在程序中实现

## 3.6 josephus问题

a 使用双链表迭代器，在迭代器上进行remove较为高效

b 时间复杂度$(m+1)*(n-1)$

假设外层循环需要x次

有 $x*n/(m+1)=n-1$,每隔m删除1个，所以是m+1,同时需要保留最后一个所以共删除n-1个元素。

则时间复杂度$n*x=(m+1)*(n-1)$

核心：保持状态的切换和连续和避免不必要的操作

## 3.7 时间复杂度

循环N次，表中数量增长1，2，...，N，每次均进行表元素复制

即(1+N)*N/2=O(N2)



## 3.8 删除表前半部分问题

a 因为在删除过程中，表的尺寸会发生改变

b N,N-1,...,N/2=(N+N/2)*(N/2)/2=O(N2)

c  因为是表首移除，时间为O(N)

d  不会变快

## 3.9 addAll问题

已实现，运行时间O(N)，在尾节点之前插入。

## 3.10  removeAll问题

对items进行排序NlogN，然后使用迭代器循环MyArrayList，利用二分法查询每个元素是否在items中，如果存在则删除。

时间复杂度O(NlogN)

## 3.11 只具有头节点的单链表

在代码中实现

主要考察链的移动，注意空指针

## 3.12 单链表排序

这个没有实现，比较简单，可以使用简单排序：冒泡，插入，选择

## 3.13 ArrayList增加ListIterator接口

已在代码中实现，主要注意索引的移动和非法性检测

## 3.14 为链表添加迭代器

已经在代码中实现，测试一定要有条理和严密，严格遵守TDD

主要注意上下指针在上下迭代过程中的切换，及其对remove和set方法的影响，使用布尔值的两种状态来表示上下切换。

## 3.15 添加splice方法

在代码中实现，没看太懂这个题，按自己的想法拼接了。

一定要有测试，代码改动后，定义要运行全部测试，同时代码一定要保证严格封装，因为实现方式随时可能会被更改。

## 3.16 提供逆向迭代器

已在代码中实现

## 3.17 在MyArrayList添加异常检测

已经在代码中实现

## 3.18 对链表添加多项操作

已经在代码中实现（头尾便捷操作）

## 3.19 无标记节点的双链表

最大的区别：由于没有标记节点，在初始情况和增加删除等变动操作中需要考虑头尾节点的特殊性，从而导致了编码复杂度增高，此题未完全实现编码，我认为重要是理解，而实际编码比较繁琐，同时知识难以迁移，意义不大。

总结：主要是通过增加辅助少量数据结构，简化编码难度，使程序结构清晰，操作简单，提升代码可读性，避免BUG的隐藏和维护的困难。

## 3.20 懒惰删除

a 优点：删除操作速度快

缺点：增删改操作变得复杂，需要考虑哪些元素已经被删除，同时需要维护附加的布尔数组。

b 

删除：

（1）删除时使用状态数组，将指定位布尔值设置为true,同时更新删除统计数字计数，

（2）当删除元素计数达到50%时，根据布尔状态数字对元素进行删除，统计重置状态数组和计数。

增加，修改，查询：

以上三个操作都需要对删除状态数组进行查询

总结：未实现代码，主要操作性和局限性比较强，是意义不大。

此题主要是延迟执行和汇总集中处理，避免频繁琐碎操作，从而提升性能这一思想。

## 3.21 平衡符号检测

a 不会这种语言

b 已经在代码中实现，不过无法检测/**/这种非单符号情况

主要使用Map（用于配对符号查询）和Set（用于确定是开放符号还是闭合符号）和Stack（存储文件中的符号）三种数据结构进行解决。

c 通过记录行号和列号进行报错。

## 3.22 编写计算后缀表达式

已完成，主要利用switch case进行判断而计算，其中使用栈存储临时计算结果，使用集合存储运算符，判断是数字还是运算符。

## 3.23 计算后缀表达式/增加幂运算/后缀转中缀

a 已完成，代码不太优雅

b 已完成，代码非常不优雅

c  已完成，代码一般。

## 3.24 编写数组实现两个栈的例程

未实现，比较简单，使用非静态内部类实现，有两种方式

1 固定大小：每个栈使用数组的一般

2 不固定大小，每个栈使用的空间动态分配

## 3.25 $O(N)$与$ \Omega logN$

操作性，未实现

a 可以使用数组或链表，内部保存一个指向最小元素的引用。

b 由于涉及到deletemin，一定存在重排问题，所以必须要进行排序

## 3.26 使用一个数组实现三个栈

操作性，不予实现

同3.24，将数组切为三份

## 3.27 栈空间是否用完问题

根据2.4节计算结果，共用栈帧x>=3/2^N,当N=50时，x=637 621 500，6亿个，极可能是用完了。

## 3.28 双端队列实现

