## 3.1 打印指定位置的值

见代码（没想出只使用Collections的public方法，在打印时使用了List的get方法）

时间复杂度$N*O(max(Collections.min(),Collections.replaceAll())$

## 3.3~3.5已经在程序中实现

## 3.6 josephus问题

a 使用双链表迭代器，在迭代器上进行remove较为高效

b 时间复杂度$(m+1)*(n-1)$

假设外层循环需要x次

有 $x*n/(m+1)=n-1$,每隔m删除1个，所以是m+1,同时需要保留最后一个所以共删除n-1个元素。

则时间复杂度$n*x=(m+1)*(n-1)$

核心：保持状态的切换和连续和避免不必要的操作

## 3.7 时间复杂度

循环N次，表中数量增长1，2，...，N，每次均进行表元素复制

即(1+N)*N/2=O(N2)



## 3.8 删除表前半部分问题

a 因为在删除过程中，表的尺寸会发生改变

b N,N-1,...,N/2=(N+N/2)*(N/2)/2=O(N2)

c  因为是表首移除，时间为O(N)

d  不会变快

## 3.9 addAll问题

已实现，运行时间O(N)，在尾节点之前插入。

## 3.10  removeAll问题

对items进行排序NlogN，然后使用迭代器循环MyArrayList，利用二分法查询每个元素是否在items中，如果存在则删除。

时间复杂度O(NlogN)

## 3.11 只具有头节点的单链表

在代码中实现

主要考察链的移动，注意空指针

## 3.12 单链表排序

这个没有实现，比较简单，可以使用简单排序：冒泡，插入，选择

## 3.13 ArrayList增加ListIterator接口

已在代码中实现，主要注意索引的移动和非法性检测

## 3.14 为链表添加迭代器

已经在代码中实现，测试一定要有条理和严密，严格遵守TDD

主要注意上下指针在上下迭代过程中的切换，及其对remove和set方法的影响，使用布尔值的两种状态来表示上下切换。

## 3.15 添加splice方法

在代码中实现，没看太懂这个题，按自己的想法拼接了。

一定要有测试，代码改动后，定义要运行全部测试，同时代码一定要保证严格封装，因为实现方式随时可能会被更改。

## 3.16 提供逆向迭代器

已在代码中实现

## 3.17 在MyArrayList添加异常检测

已经在代码中实现

## 3.18 对链表添加多项操作

已经在代码中实现（头尾便捷操作）

## 3.19 无标记节点的双链表

最大的区别：由于没有标记节点，在初始情况和增加删除等变动操作中需要考虑头尾节点的特殊性，从而导致了编码复杂度增高。

总结：主要是通过增加辅助少量数据结构，简化编码难度，使程序结构清晰，操作简单，提升代码可读性，避免BUG的隐藏和维护的困难。

未实现，操作性题。

## 3.20 懒惰删除

a 优点：删除操作速度快

缺点：增删改操作变得复杂，需要考虑哪些元素已经被删除，同时需要维护附加的布尔数组。

b 

删除：

（1）删除时使用状态数组，将指定位布尔值设置为true,同时更新删除统计数字计数，

（2）当删除元素计数达到50%时，根据布尔状态数字对元素进行删除，统计重置状态数组和计数。

增加，修改，查询：

以上三个操作都需要对删除状态数组进行查询

总结：未实现代码，主要操作性和局限性比较强，是意义不大。

此题主要是延迟执行和汇总集中处理，避免频繁琐碎操作，从而提升性能这一思想。

## 3.21 平衡符号检测

a 不会这种语言

b 已经在代码中实现，不过无法检测/**/这种非单符号情况

主要使用Map（用于配对符号查询）和Set（用于确定是开放符号还是闭合符号）和Stack（存储文件中的符号）三种数据结构进行解决。

c 通过记录行号和列号进行报错。

## 3.22 编写计算后缀表达式

已完成，主要利用switch case进行判断而计算，其中使用栈存储临时计算结果，使用集合存储运算符，判断是数字还是运算符。

## 3.23 计算后缀表达式/增加幂运算/后缀转中缀

a 已完成，代码不太优雅

b 已完成，代码非常不优雅

c  已完成，代码一般。

![](D:\learn\algorithm\data_structure_and_algorithm_analysis_java3th\image\Infix2suffix.JPG)

## 3.24 编写数组实现两个栈的例程

未实现，比较简单，使用非静态内部类实现，有两种方式

1 固定大小：每个栈使用数组的一般

2 不固定大小，每个栈使用的空间动态分配

## 3.25 $O(N)$与$ \Omega logN$

操作性，未实现

a 可以使用数组或链表，内部保存一个指向最小元素的引用。

b 由于涉及到deletemin，一定存在重排问题，所以必须要进行排序

## 3.26 使用一个数组实现三个栈

操作性，不予实现

同3.24，将数组切为三份

## 3.27 栈空间是否用完问题

根据2.4节计算结果，共用栈帧x>=3/2^N,当N=50时，x=637 621 500，6亿个，极可能是用完了。

## 3.28 双端队列实现

使用双链表，已实现，主要考察双链表链的使用，已掌握无其他收获。

## 3.29 链表的逆序打印

此题与3.16重复

## 3.30 自调整表

a 数组可以通过remove来实现，时间复杂度O(N)，考察数组的移动

b 链表remove实现较为高效，时间复杂度O(1)，考察链的移动

c 此题不证自明，假设访问k次，共N个元素，k次访问种某一元素至少被访问一次的概率为$1-(1-p_i)^{k}$,可以得出概率越大的元素被访问的概率越高。

此题非有效练习，不予实现。

## 3.31 单链表实现栈

此题考察单链表的单向性

由于单链表具有单向性，实现栈时，使用表头作为栈顶，入栈使用头插法，如不采用此法，出栈时间复杂度为O(N)

不用头尾节点对此无大影响，使用两个指针记录首元素节点和尾元素节点，每次入栈出栈进行更新即可。

此题非有效练习，不予实现。

## 3.32 使用单链表实现队列

此题考察单链表的单向性和链的操作

入栈在表尾，出栈在表头

其他同3.21

此题非有效练习，不予实现。

## 3.33 使用循环数组实现队列

此题考察循环数组的使用

主要考察取余操作的使用，使用辅助结构简化代码，数组扩张策略等四个知识点。

核心问题是（1）头尾索引的移动，（2）表中元素数量的判断，（3）剩余空间的判断（4）动态扩张四个问题。

（1）使用取余的方式进行索引的循环移动

（2）（3）使用theSize记录实现，这样虽然引入了辅助计数，但是提高了程序的可读性和降低编程的难度

（4）当数组满时，使用2n+1或n+0.5n策略进行扩张

收获：取余操作具有循环的特性

## 3.34 循环链表判断问题

未看懂此题，用一个标记节点做标记，循环一下，判断一下对象地址应该可以判断循环。

此题未编码

收获：无

## 3.35 循环链表队列问题

a 出队为O1，入队为ON，因为表中第一项的prev找不到最后一项

b 出入队均为O1，因为左后一项的next可以找到第一项

收获：单向链表尾节点便捷首位操作与队列特性刚好相符合

## 3.6 单链表元素删除问题

假设要删除的节点为A，因为单链表的单向性，无法知道A上一元素，但是可以知道A下一节点B，

所以可以将B中内容保存到A，再将B删除（偷梁换柱）。

收获：单链表的单向性

## 3.37 单链表O1插入删除操作问题

原理同3.6