## 5.1/5.2 考察4种基本散列函数的hash function和再散列
$\{4371，1323，6173，4199，4344，9679，1989\}$

$TableSize=10$

+ 分离链接散列表

$hash(x)=x \ mod \ 10$

$[[4371],[6173,1323],[4344,],[1989,9679,4199]]$

|  0   |                |
| :--: | :------------- |
|  1   | 4371           |
|  2   |                |
|  3   | 6173,1323      |
|  4   | 4344           |
|  5   |                |
|  6   |                |
|  7   |                |
|  8   |                |
|  9   | 1989,9679,4199 |

2*10后下一个素数为23

h(x)=x mod 23

| 0    |      |
| ---- | ---- |
| 1    | 4371 |
| 2    |      |
| 3    |      |
| 4    |      |
| 5    |      |
| 6    |      |
| 7    |      |
| 8    |      |
| 9    | 6173 |
| 10   |      |
| 11   | 1989 |
| 12   | 1323 |
| 13   | 4199 |
| 14   |      |
| 15   |      |
| 16   |      |
| 17   |      |
| 18   |      |
| 19   | 9679 |
| 20   | 4344 |
| 21   |      |
| 22   |      |

+ 线性探测散列表

$h_i(x)=(hash(x)+f(i)) \ mod \ 10$

$h_i(x)=(x+f(i)) \ mod \ 10$

$f(i)=i$

$h_0(x),h_1(x),...,h_{n-1}(x)$

| 0    | 9679 |
| ---- | ---- |
| 1    | 4371 |
| 2    | 1989 |
| 3    | 1323 |
| 4    | 6173 |
| 5    | 4344 |
| 6    |      |
| 7    |      |
| 8    |      |
| 9    | 4199 |

再散列h(x) = (hash(x) + i) mod 23, 由于没有冲突和链式结果相同

+ 平方探测法

$h_i(x)=(hash(x)+f(i)) \ mod \ 10$

$f(i)=i^2$

| 0    | 9679 |
| ---- | ---- |
| 1    | 4371 |
| 2    |      |
| 3    | 1323 |
| 4    | 6173 |
| 5    | 4344 |
| 6    |      |
| 7    |      |
| 8    | 1989 |
| 9    | 4199 |

再散列h(x)=(hash(x) + i^2) mod 23, 由于没有冲突和链式结果相同

+ 双散列

$h_i(x)=(hash(x)+f(i)) \  mod \ 10$

$f(i)=i*hash_2(x)$

$h_2(x)=7-(x \ mod \ 7)$

| 0    |      |
| ---- | ---- |
| 1    | 4371 |
| 2    |      |
| 3    | 1323 |
| 4    | 6173 |
| 5    | 9679 |
| 6    |      |
| 7    | 4344 |
| 8    |      |
| 9    | 4199 |

1989无法放入此表，需要再散列。

再散列h(x)=(hash(x) + i*hash2(x)) mod 23，由于没有冲突和链式结果相同。

## 5.3 使用程序计算四种基本散列插入冲突次数

在程序中实现

插入和再散列过程中：

线性探测冲突较多，但速度最快，平方探测冲突较少，但是速度最慢，双散列处于中间，受R值的影响较大，不确定是否随着表的增大R值应该动态变化还是固定值。

## 5.4 关于表放缩时填装因子$\lambda$的取值

根据题意，$\lambda=2$进行再散列，表变为原表二倍，散列后$\lambda=1$

所以可以猜测，插入过程中$\lambda \in [1,2]$，删除过程中$\lambda \in [1,0.5]$

## 5.5 使用单链表实现分离链接散列表

已经实现，但是用双链表。

## 5.6平方探测isEmpty例程实现

过于简单，未实现

## 5.7 非活动单元插入问题

a 已在代码中实现

b 当存在大量删除和插入时，运行速度将快于原来的算法，同时如果经常查询最近插入的元素，也会快于原始算法，重写的算法不可能会更慢。

## 5.8 立方探测和平方探测性能对比

已经在代码中测试，不过代码中平方探测运行速度太慢，原因不明，对比结果无效，但是立方探测数值更大，更加稀疏，会存在较多的取余运算，立方计算量也高于平方，运行时间应该是比平方更慢。

## 5.9 key.length的重复计算

不值得，该值是固定不变的，只需计算一次即可。

## 5.10 各冲突解决方案的优缺点

| 冲突解决方案 | 优点                               | 缺点                                                    |
| ------------ | ---------------------------------- | ------------------------------------------------------- |
| 分离链表     | 不需要惰性删除，允许填装因子接近1  | 需要额外空间，需要new对象                               |
| 线性探测     | 计算快速                           | 容易1次聚集，填装因子最好<0.5                           |
| 平方探测     | 解决一次聚集                       | 容易2次聚集，填装因子严格<0.5                           |
| 双散列       | 接近随机冲突解决方案，冲突次数较小 | 需要计算两次散列函数，代价较高，同时R值需要选取合理值。 |

## 5.11 $f(x)=i*r(hash(x))$冲突方案对比

$r(y)=|48271 \ y \ (mod \ (2^{31}-1))|mod \ TableSize$

该方法将相聚k的y和y+k的距离放大到48271k，再进行两次折叠。

相比于平方探测，相比于$i^2，$$r*hash(x)$可以大概率避免探测相同位置。

相比于双散列，相比于$i*hash2(x)$，$i*r(hash(x))$可以避免二次哈希值的计算。

